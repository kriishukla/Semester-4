# -*- coding: utf-8 -*-
"""SML_assn3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ngj4S-rfHRJ-tJgyoCgb6CpZ-l2TZi2i
"""

import numpy as np

file_path = '/content/drive/MyDrive/mnist.npz'
file = np.load(file_path)
x_train=file['x_train']
y_train=file['y_train']

print(x_train)
print(y_train)

print(x_train.shape)
print(y_train.shape)

X=[]
Y=[]
for i in range(y_train.shape[0]):
  if y_train[i]==0 or y_train[i]==1 or y_train[i]==2:
    X.append(x_train[i])
    Y.append(y_train[i])
X = np.array(X)
Y = np.array(Y)

print(X.shape)
print(Y.shape)
print(np.unique(Y))
print(X)

X = X.reshape(X.shape[0], -1)
mean = np.mean(X, axis=0)
std_dev = np.std(X, axis=0)
epsilon = 1e-8
x_train_selected_std = (X - mean) / (std_dev + epsilon)
x_train_selected_std

cov_mat = np.cov(x_train_selected_std, rowvar=False)
cov_mat

eig_vals, eig_vecs = np.linalg.eigh(cov_mat)
eig_vals

sorted_indices = np.argsort(eig_vals)[::-1]
sorted_eig_vecs = eig_vecs[:, sorted_indices]
sorted_eig_vecs

selected_eig_vecs = sorted_eig_vecs[:, :10]
selected_eig_vecs

X = np.dot(x_train_selected_std, selected_eig_vecs)
X

print(X.shape)
print(Y.shape)

import matplotlib.pyplot as plt
import random

num_plots = 10


sample_size = 1000

sample_indices = random.sample(range(len(X)), sample_size)

fig, axs = plt.subplots(num_plots, 1, figsize=(8, 6*num_plots))


for j in range(num_plots):

    x_values = [X[i][j] for i in sample_indices]
    y_values = [Y[i] for i in sample_indices]

    axs[j].scatter(x_values, y_values, color='red', label='Feature {}'.format(j))
    axs[j].set_xlabel('X[{}]'.format(j))
    axs[j].set_ylabel('Y')
    axs[j].set_title('Relationship between X[{}] and Y (Sampled)'.format(j))
    axs[j].legend()
    axs[j].grid(True)

plt.tight_layout()
plt.show()

x=X[:100]
y=Y[:100]
print(x.shape)
print(y.shape)
print(X.shape)
print(Y.shape)

def gini_index(groups, classes):
    n_instances = float(sum([len(group) for group in groups]))
    gini = 0.0
    for group in groups:
        size = float(len(group))
        if size == 0:
            continue
        score = 0.0
        for class_val in classes:
            p = [row[-1] for row in group].count(class_val) / size
            score += p * p
        gini += (1.0 - score) * (size / n_instances)
    return gini

import numpy as np

min_val = [1e9 + 1]*11
max_val = [-1e9 - 1]*11
sum_val = np.zeros(10)

for j in range(10):
    for i in range(X.shape[0]):
        if X[i][j] < min_val[j]:
            min_val[j] = X[i][j]

        if X[i][j] > max_val[j]:
            max_val[j] = X[i][j]

        sum_val[j] += X[i][j]
avg_val = sum_val / X.shape[0]

print("Min:", min_val)
print("Max:", max_val)
print("Average:", avg_val)

midpt=[0]*10
print(len(min_val))
print(len(max_val))
for i in range(10):
    midpt[i]=(min_val[i]+max_val[i])/2

print(midpt)
midpt=avg_val

arr_left = [[] for _ in range(10)]
arr_right = [[] for _ in range(10)]
for j in range(10):
    for i in range(X.shape[0]):
          if X[i][0]<midpt[j]:
              arr_left[j].append(Y[i])

          if X[i][0]>midpt[j]:
              arr_right[j].append(Y[i])

print(arr_left)
print(arr_right)
for x in range(len(arr_left)):
    left_counts = np.bincount(np.array(arr_left[x]))
    right_counts = np.bincount(np.array(arr_right[x]))

    total_left = len(np.array(arr_left[x]))
    total_right = len(np.array(arr_right[x]))

    percentage_left = left_counts / total_left * 100
    percentage_right = right_counts / total_right * 100

    print()
    for i, count in enumerate(percentage_left):
        print(f"Class {i}: {count:.2f}%")

    print()
    for i, count in enumerate(percentage_right):
        print(f"Class {i}: {count:.2f}%")

    print()

gini_indices = []

for j in range(10):
    arr_left = []
    arr_right = []

    for i in range(X.shape[0]):
        if X[i][0] < midpt[j]:
            arr_left.append(Y[i])
        elif X[i][0] > midpt[j]:
            arr_right.append(Y[i])

    left_counts = np.bincount(np.array(arr_left))
    right_counts = np.bincount(np.array(arr_right))
    total_left = len(np.array(arr_left))
    total_right = len(np.array(arr_right))

    gini_left = 1.0 - sum((np.array(left_counts) / total_left) ** 2)
    gini_right = 1.0 - sum((np.array(right_counts) / total_right) ** 2)

    gini_index = (total_left * gini_left + total_right * gini_right) / (total_left + total_right)

    gini_indices.append((j, gini_index))

gini_indices.sort(key=lambda x: x[1])

best_divisions = gini_indices[:2]

print("Best divisions for a tree with max depth 2 and 2 features:")
for division in best_divisions:
    print("Division:", division[0], "Gini index:", division[1])

gini_indices = []

for j in range(X.shape[1]):
    cnt1 = 0
    cnt2 = 0
    cnt3 = 0
    cnt4 = 0
    cnt5 = 0
    cnt6 = 0
    arr_left = [[] for _ in range(3)]
    arr_right = [[] for _ in range(3)]

    for i in range(X.shape[0]):
        if X[i][j] < midpt[j]:
            cnt3 += 1
            arr_left[Y[i]].append(Y[i])
            if Y[i] == 0:
                cnt1 += 1
            elif Y[i] == 1:
                cnt2 += 1
        elif X[i][j] > midpt[j]:
            cnt4 += 1
            arr_right[Y[i]].append(Y[i])
            if Y[i] == 0:
                cnt5 += 1
            elif Y[i] == 1:
                cnt6 += 1
    # print(arr_left)
    # print(arr_right)
    a = max(cnt1, cnt2, cnt3 - cnt1 - cnt2)
    o = max(cnt5, cnt6, cnt4 - cnt5 - cnt6)
    total_left = cnt3
    total_right = cnt4

    gini_left = 1 - sum((len(arr_left[k]) / total_left) ** 2 for k in range(3))
    gini_right = 1 - sum((len(arr_right[k]) / total_right) ** 2 for k in range(3))

    gini_index = (total_left * gini_left + total_right * gini_right) / (total_left + total_right)

    gini_indices.append((j, gini_index))

print(gini_indices)

best_split = None
best_gini_index = float('inf')

for j1 in range(X.shape[1]):
    for j2 in range(j1+1, X.shape[1]):
        midpt1 = midpt[j1]
        midpt2 = midpt[j2]

        cnt = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        arr_leaf = [[[[], [], []] for _ in range(3)] for _ in range(3)]

        for k in range(X.shape[0]):
            if X[k][j1] < midpt1:
                if X[k][j2] < midpt2:
                    cnt[0][Y[k]] += 1
                    arr_leaf[0][Y[k]][0].append(k)
                else:
                    cnt[1][Y[k]] += 1
                    arr_leaf[0][Y[k]][1].append(k)
            else:
                if X[k][j2] < midpt2:
                    cnt[2][Y[k]] += 1
                    arr_leaf[0][Y[k]][2].append(k)
                else:
                    cnt[1][Y[k]] += 1
                    arr_leaf[1][Y[k]][2].append(k)

        gini_index = 0
        total = sum(sum(cnt_leaf) for cnt_leaf in cnt)

        for l in range(3):
            if sum(cnt[l]) == 0:
                gini_leaf = 0
            else:
                gini_leaf = 1 - sum((cnt[l][c] / sum(cnt[l])) ** 2 for c in range(3))
            gini_index += sum(cnt[l]) / total * gini_leaf

        if gini_index < best_gini_index:
            best_gini_index = gini_index
            best_split = ((j1, midpt1), (j2, midpt2))

print("Best Split (feature index, threshold) for each split node:", best_split)
print("Best Gini Index:", best_gini_index)

gini_indices = []

for j in range(10):
    arr_left = []
    arr_right = []

    for i in range(X.shape[0]):
        if X[i][j] < midpt[j]:
            arr_left.append(Y[i])
        elif X[i][j] > midpt[j]:
            arr_right.append(Y[i])

    left_counts = np.bincount(np.array(arr_left))
    right_counts = np.bincount(np.array(arr_right))
    total_left = len(np.array(arr_left))
    total_right = len(np.array(arr_right))

    gini_left = 1.0 - sum((np.array(left_counts) / total_left) ** 2)
    gini_right = 1.0 - sum((np.array(right_counts) / total_right) ** 2)

    gini_index = (total_left * gini_left + total_right * gini_right) / (total_left + total_right)

    gini_indices.append((j, gini_index))

gini_indices.sort(key=lambda x: x[1])

print("Gini indices for all 10 dimensions:")
for division in gini_indices:
    print("Dimension:", division[0], "Gini index:", division[1])

x_test=file['x_test']
y_test=file['y_test']
x_t=[]
y_t=[]
for i in range(y_test.shape[0]):
  if y_test[i]==0 or y_test[i]==1 or y_test[i]==2:
    x_t.append(x_test[i])
    y_t.append(y_test[i])
x_t = np.array(x_t)
y_t = np.array(y_t)

print(x_t.shape)
print(y_t.shape)

x_t = x_t.reshape(x_t.shape[0], -1)
mean = np.mean(x_t, axis=0)
std_dev = np.std(x_t, axis=0)
epsilon = 1e-8
x_test_selected = (x_t - mean) / (std_dev + epsilon)
x_test_selected

cov_mat = np.cov(x_test_selected, rowvar=False)
cov_mat

eig_vals, eig_vecs = np.linalg.eigh(cov_mat)
eig_vals

selected_eig_vecs = sorted_eig_vecs[:, :10]

X_t = np.dot(x_test_selected, selected_eig_vecs)

print(X_t.shape)
print(y_t.shape)

pred=[]
for i in range(X_t.shape[0]):
    if X_t[i][0]>midpt[0]:
        pred.append(0)
    else:
        if X_t[i][1]<midpt[1]:
            pred.append(2)
        else:
            pred.append(1)

print(len(pred))

cntr=0
for i in range(len(pred)):
    if pred[i]==y_t[i]:
        cntr+=1
print(cntr/len(pred))

cnt1=0
cnt2=0
cnt3=0
cnt4=0
cnt5=0
cnt6=0
for i in range(len(y_t)):
    if y_t[i]==0:
        cnt4+=1
        if pred[i]==y_t[i]:
            cnt1+=1
    if y_t[i]==1:
        cnt5+=1
        if pred[i]==y_t[i]:
            cnt2+=1
    if y_t[i]==2:
        cnt6+=1
        if pred[i]==y_t[i]:
            cnt3+=1
cnt7=0
cnt8=0
cnt9=0
for i in pred:
    if i==0:
        cnt7+=1
    if i==1:
        cnt8+=1
    if i==2:
        cnt9+=1

print(cnt1,cnt2,cnt3,cnt4,cnt5,cnt6,cnt7,cnt8,cnt9)


print("class 0 accuracy",(cnt1/cnt4)*100,"%")
print("class 1 accuracy",(cnt2/cnt5)*100,"%")
print("class 2 accuracy",(cnt3/cnt6)*100,"%")

top_splits = []

for j1 in range(X.shape[1]):
    for j2 in range(j1+1, X.shape[1]):
        midpt1 = midpt[j1]
        midpt2 = midpt[j2]

        cnt = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        arr_leaf = [[[[], [], []] for _ in range(3)] for _ in range(3)]

        for k in range(X.shape[0]):
            if X[k][j1] < midpt1:
                if X[k][j2] < midpt2:
                    cnt[0][Y[k]] += 1
                    arr_leaf[0][Y[k]][0].append(k)
                else:
                    cnt[1][Y[k]] += 1
                    arr_leaf[0][Y[k]][1].append(k)
            else:
                if X[k][j2] < midpt2:
                    cnt[2][Y[k]] += 1
                    arr_leaf[0][Y[k]][2].append(k)
                else:
                    cnt[1][Y[k]] += 1
                    arr_leaf[1][Y[k]][2].append(k)

        gini_index = 0
        total = sum(sum(cnt_leaf) for cnt_leaf in cnt)

        for l in range(3):
            if sum(cnt[l]) == 0:
                gini_leaf = 0
            else:
                gini_leaf = 1 - sum((cnt[l][c] / sum(cnt[l])) ** 2 for c in range(3))
            gini_index += sum(cnt[l]) / total * gini_leaf

        top_splits.append((gini_index, ((j1, midpt1), (j2, midpt2))))
        top_splits.sort(key=lambda x: x[0])
        top_splits = top_splits[:5]

print("Top 5 Splits (feature index, threshold) for each split node:")
for i, (gini_index, split) in enumerate(top_splits, 1):
    print(f"Split {i}: {split}, Gini Index: {gini_index}")

pred1=[]
for i in range(X_t.shape[0]):
    if X_t[i][1]>midpt[1]:
        pred1.append(2)
    else:
        if X_t[i][8]<midpt[8]:
            pred1.append(1)
        else:
            pred1.append(0)

print(len(pred1))
len(y_t)

pred1=[]
for i in range(X_t.shape[0]):
    if X_t[i][1]<midpt[1]:
        pred1.append(2)
    else:
        if X_t[i][8]<midpt[8]:
            pred1.append(1)
        else:
            pred1.append(0)

print(len(pred1))
len(y_t)

print(len(pred1))
cntr=0
for i in range(len(pred1)):
    if pred1[i]==y_t[i]:
        cntr+=1
print(cntr/len(pred1))

pred2=[]
for i in range(X_t.shape[0]):
    if X_t[i][0]>midpt[0]:
        pred2.append(0)
    else:
        if X_t[i][8]<midpt[8]:
            pred2.append(1)
        else:
            pred2.append(0)

print(len(pred2))

cntr=0
for i in range(len(pred2)):
    if pred2[i]==y_t[i]:
        cntr+=1
print(cntr/len(pred2))

pred3=[]
for i in range(X_t.shape[0]):
    if X_t[i][0]>midpt[0]:
        pred3.append(0)
    else:
        if X_t[i][2]<midpt[2]:
            pred3.append(1)
        else:
            pred3.append(0)

print(len(pred3))
cntr=0
for i in range(len(pred3)):
    if pred3[i]==y_t[i]:
        cntr+=1
print(cntr/len(pred3))

pred4=[]
for i in range(X_t.shape[0]):
    if X_t[i][1]<midpt[1]:
        pred4.append(1)
    else:
        if X_t[i][9]>midpt[9]:
            pred4.append(0)
        else:
            pred4.append(1)

print(len(pred4))
cntr=0
for i in range(len(pred4)):
    if pred4[i]==y_t[i]:
        cntr+=1
print(cntr/len(pred4))

import numpy as np

num_iterations = 5

a = []
b = []
c = []
d = []
e = []

for i in range(len(X)):
    random_index = np.random.randint(5)

    if random_index == 0:
        a.append(X[i])
    elif random_index == 1:
        b.append(X[i])
    elif random_index == 2:
        c.append(X[i])
    elif random_index == 3:
        d.append(X[i])
    else:
        e.append(X[i])

a = np.array(a)
b = np.array(b)
c = np.array(c)
d = np.array(d)
e = np.array(e)

print("Shape of array a:", a.shape)
print("Shape of array b:", b.shape)
print("Shape of array c:", c.shape)
print("Shape of array d:", d.shape)
print("Shape of array e:", e.shape)

min_vals = [[1e9 + 1] * 10 for _ in range(5)]
max_vals = [[-1e9 - 1] * 10 for _ in range(5)]

arrays = [a, b, c, d, e]

for k, array in enumerate(arrays):
    for i in range(len(array)):
        for j in range(10):
            if array[i][j] < min_vals[k][j]:
                min_vals[k][j] = array[i][j]
            if array[i][j] > max_vals[k][j]:
                max_vals[k][j] = array[i][j]

min_val1, min_val2, min_val3, min_val4, min_val5 = min_vals
max_val1, max_val2, max_val3, max_val4, max_val5 = max_vals

midpts = []

for array in [a, b, c, d, e]:
    midpt = [(min_val + max_val) / 2 for min_val, max_val in zip(np.min(array, axis=0), np.max(array, axis=0))]
    midpts.append(midpt)

midpt1, midpt2, midpt3, midpt4, midpt5 = midpts
print(midpt1)
print(midpt2)
print(midpt3)
print(midpt4)
print(midpt5)

def find_best_split(X, Y, midpt):
    best_split = None
    best_gini_index = float('inf')

    for j1 in range(X.shape[1]):
        for j2 in range(j1 + 1, X.shape[1]):
            midpt1 = midpt[j1]
            midpt2 = midpt[j2]

            cnt = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
            arr_leaf = [[[[], [], []] for _ in range(3)] for _ in range(3)]

            for k in range(X.shape[0]):
                if X[k][j1] < midpt1:
                    if X[k][j2] < midpt2:
                        cnt[0][Y[k]] += 1
                        arr_leaf[0][Y[k]][0].append(k)
                    else:
                        cnt[1][Y[k]] += 1
                        arr_leaf[0][Y[k]][1].append(k)
                else:
                    if X[k][j2] < midpt2:
                        cnt[2][Y[k]] += 1
                        arr_leaf[0][Y[k]][2].append(k)
                    else:
                        cnt[1][Y[k]] += 1
                        arr_leaf[1][Y[k]][2].append(k)

            gini_index = 0
            total = sum(sum(cnt_leaf) for cnt_leaf in cnt)

            for l in range(3):
                if sum(cnt[l]) == 0:
                    gini_leaf = 0
                else:
                    gini_leaf = 1 - sum((cnt[l][c] / sum(cnt[l])) ** 2 for c in range(3))
                gini_index += sum(cnt[l]) / total * gini_leaf

            if gini_index < best_gini_index:
                best_gini_index = gini_index
                best_split = ((j1, midpt1), (j2, midpt2))

    return best_split, best_gini_index

best_splits = []
best_gini_indices = []

for dataset, midpt in zip([a, b, c, d, e], [midpt1, midpt2, midpt3, midpt4, midpt5]):
    best_split, best_gini_index = find_best_split(dataset, Y, midpt)
    best_splits.append(best_split)
    best_gini_indices.append(best_gini_index)

print("Best Splits (feature index, threshold) for each array:")
for i, (split, gini_index) in enumerate(zip(best_splits, best_gini_indices), 1):
    print(f"Array {i}: {split}, Gini Index: {gini_index}")

pred_model1 = []
for i in range(X_t.shape[0]):
    if X_t[i][0] < midpt[0]:
        pred_model1.append(0)
    else:
        if X_t[i][9] < midpt[9]:
            pred_model1.append(1)
        else:
            pred_model1.append(2)

print(len(pred_model1))

pred_model2 = []
for i in range(X_t.shape[0]):
    if X_t[i][1]<midpt[1]:
        pred_model2.append(2)
    else:
        if X_t[i][8]<midpt[8]:
            pred_model2.append(1)
        else:
            pred_model2.append(0)

pred_model3 = []
for i in range(X_t.shape[0]):
    if X_t[i][0] > midpt[0]:
        pred_model3.append(0)
    else:
        if X_t[i][1] < midpt[1]:
            pred_model3.append(2)
        else:
            pred_model3.append(1)

print(len(pred_model3))

predx=[]
for i in range(X_t.shape[0]):
    if X_t[i][0]>midpt[0]:
        predx.append(0)
    else:
        if X_t[i][1]<midpt[1]:
            predx.append(2)
        else:
            predx.append(1)

print(len(predx))

pred1=[]
for i in range(X_t.shape[0]):
    if X_t[i][1]<midpt[1]:
        pred1.append(2)
    else:
        if X_t[i][8]<midpt[8]:
            pred1.append(1)
        else:
            pred1.append(0)

print(len(pred1))
len(y_t)

print(len(pred1))
cntr=0
for i in range(len(pred1)):
    if pred1[i]==y_t[i]:
        cntr+=1
print(cntr/len(pred1))

y_pred = y_t.copy()
predicted_classes = []
indices_to_remove = []

for i in range(len(y_t)):
    counts = [0, 0, 0]

    for pred in [pred_model1[i], pred_model2[i],pred_model3[i]]:
        counts[pred] += 1
    counts[pred_model3[i]] += 1

    max_count = max(counts)
    if max_count >= 3:
        predicted_classes.append(counts.index(max_count))
    else:
        predicted_classes.append(y_pred[i])

y_pred = np.delete(y_pred, indices_to_remove)
print(len(predicted_classes))

x=0
for i in range(len(y_pred)):
    if y_pred[i]==predicted_classes[i]:
        x+=1

print(x/len(y_t))

